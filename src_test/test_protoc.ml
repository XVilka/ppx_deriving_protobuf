open OUnit2

let () = Protoc_outer.(())

let test_protoc ctxt =
  let read filename =
    let path = Filename.concat (Filename.dirname Sys.executable_name) filename in
    let file = open_in path in
    let contents = really_input_string file (in_channel_length file) in
    close_in file;
    Str.global_replace (Str.regexp " +$") "" contents
  in
  let actual_protoc_outer     = read "Protoc_outer.protoc"
  and actual_protoc_outer_mod = read "Protoc_outer.Mod.protoc"
  and actual_protoc_inner     = read "Protoc_inner.protoc"
  in
  let expected_protoc_outer =
{|// protoc file autogenerated from OCaml type definitions
package Protoc_outer;

// src_test/protoc_outer.ml:3
message m1 {
  required bool f1 = 1;
  required int64 f2 = 2;
  required sint64 f3 = 3;
  required sfixed32 f4 = 4;
  required sfixed64 f5 = 5;
  required int32 f6 = 6;
  required sint32 f7 = 7;
  required sfixed32 f8 = 8;
  required sfixed64 f9 = 9;
  required int64 f10 = 10;
  required sint64 f11 = 11;
  required sfixed32 f12 = 12;
  required sfixed64 f13 = 13;
  required uint32 f14 = 14;
  required sint32 f15 = 15;
  required sfixed32 f16 = 16;
  required sfixed64 f17 = 17;
  required uint64 f18 = 18;
  required sint64 f19 = 19;
  required sfixed32 f20 = 20;
  required sfixed64 f21 = 21;
  required float f22 = 22;
  required double f23 = 23;
  required string f24 = 24;
  required bytes f25 = 25;
  optional int64 f26 = 26;
  repeated int64 f27 = 27;
  repeated int64 f28 = 28 [packed=true];
}

// src_test/protoc_outer.ml:35
message m2 {
  enum _tag {
    A_tag = 1;
    B_tag = 2;
    C_tag = 3;
  }

  // src_test/protoc_outer.ml:39
  message _C {
    required int64 _0 = 1;
    required int64 _1 = 2;
  }

  required _tag tag = 1;
  oneof value {
    int64 B = 3;
    _C C = 4;
  }
}

// src_test/protoc_outer.ml:41
message m3 {
  enum _tag {
    D_tag = 1;
    E_tag = 2;
  }

  required _tag tag = 1;
}

// src_test/protoc_outer.ml:46
message m4 {
  // src_test/protoc_outer.ml:52
  message _f3 {
    enum _tag {
      A_tag = 1;
    }

    required _tag tag = 1;
  }

  // src_test/protoc_outer.ml:52
  message _f4 {
    enum _tag {
      A_tag = 1;
    }

    required _tag tag = 1;
  }

  required m3 f1 = 1;
  required m3._tag f2 = 2;
  required _f3 f3 = 3;
  required _f4._tag f4 = 4;
}

// src_test/protoc_outer.ml:54
message m5 {
  // src_test/protoc_outer.ml:63
  message _f6 {
    enum _tag {
      A_tag = 1;
    }

    required _tag tag = 1;
  }

  required bool f1 = 1 [default=true];
  required bool f2 = 2 [default=false];
  required int64 f3 = 3 [default=42];
  required string f4 = 4 [default="foo\"\x0aÐ¹"];
  required bytes f5 = 5 [default="foo\"\x0a\xd0\xb9"];
  required _f6._tag f6 = 6 [default=A_tag];
  required m3._tag f7 = 7 [default=D_tag];
}

// src_test/protoc_outer.ml:65
import "Protoc_inner.protoc";
message m6 {
  required Protoc_inner.foo _ = 1;
}

// src_test/protoc_outer.ml:72
import "Protoc_outer.Mod.protoc";
message m7 {
  required Mod.foo _ = 1;
}
|}
  and expected_protoc_outer_mod =
{|// protoc file autogenerated from OCaml type definitions
package Protoc_outer.Mod;

// src_test/protoc_outer.ml:69
message foo {
  required int64 _ = 1;
}
|}
  and expected_protoc_inner =
{|// protoc file autogenerated from OCaml type definitions
package Protoc_inner;

// src_test/protoc_inner.ml:1
message foo {
  required int64 _ = 1;
}
|}
  in
  assert_equal ~printer:(fun s -> s) actual_protoc_outer expected_protoc_outer;
  assert_equal ~printer:(fun s -> s) actual_protoc_outer_mod expected_protoc_outer_mod;
  assert_equal ~printer:(fun s -> s) actual_protoc_inner expected_protoc_inner

let suite = "Test protoc" >:: test_protoc
